What happens when you initialize a repository? Why do you need to do it?
When you run git init, you are creating a hidden folder that will track changes to the repository called .git. Without this file, Git will not know what versions you have previously worked on - or where you are currently active.

How is the staging area different from the working directory and the repository? What value do you think it offers?
The staging area is a place to check that what you are going to commit all belongs together, before running the commit. It allows there to be other files in the working directory, that are not necessarily part of the project that you can then ensure aren't committed.

How can you use the staging area to make sure you have one commit per logical change?
By using git diff we can check that we have only added changes to the staging area that are logically grouped together. They can then be committed at once. We could then add some more files from working dorectory to staging and repeat, keeping them separate.
The only problem will be if you have two logical changes that exist in the same file. These would have to be committed together.

What are some situations when branches would be helpful in keeping your history organized? How would branches help?
Any major functional change would be a good candidate for a branch. Allowing the code to stay in a known working state and maybe receive any required bug fixes completely outside of any new changes that shouldn't yet go live. This has happened several times to me. Whilst trying to restructure a part of an application in development, a user will report a bug on the live version. I cannot fix the bug and publish it, because the whole file is now different to what the user sees. To be able to work on two versions of the same file, for 2 different reasons is very powerful.

